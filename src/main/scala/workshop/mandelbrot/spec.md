## Introduction
This lab will be in 2 phases :

- The implementation of a component which is able to calculate the mandelbrot value of a given XY coordinate
- The implementation of the same functionality but by a multicore manner by using the precedent phase implementation and some arbitration.

## Mandelbrot fractal
Mandelbrot pictures are generated by the following way :

- For each pixel of the screen there is an coordinate in the mandelbrot space
- A mandelbrot function will return the number of iteration used to "resolve" each coordinate
- This number of iteration is translated into a color for each pixel of the screen

The mandelbrot function in scala could be the following :

```scala
val maxIterations = 255
def mandelbrot(x0 : Double,y0 : Double) : Int = {
  var x = 0.0
  var y = 0.0
  var iteration = 0
  
  while (x*x + y*y < 4 && iteration < maxIterations) {
    val xNext = x*x - y*y + x0
    val yNext = 2*x*y + y0
    x = xNext
    y = yNext
    iteration = iteration + 1
  }
  return iteration
}
```

So, The first phase of this lab will be to implement this function in hardware by using SpinalHDL.

You can find more information on the [wikipedia](https://en.wikipedia.org/wiki/Mandelbrot_set)

## Part 1 : PixelSolver

The component will receive one stream of pixel tasks (which contain the XY coordinates in the mandelbrot space) and will produce one stream of pixel results (which contain the number of iteration done for the corresponding task)

Following constructions parameters are given to the PixelSolver :

| Name | Type | Description |
| ------- | ---- |  --- | --- |
| fixAmplitude | Int | 2^fixAmplitude represent the fixed point maximal value |
| fixResolution | Int | 2^fixResolution represent the fixed point resolution |
| iterationLimit | Int | Maximal number of iteration allowed per XY coordinates |

Let's specify the IO of our component :

| IO Name | Direction | Type | Description |
| ------- | ---- |  --- | --- |
| cmd | slave | Stream(PixelTask)  | Provide XY coordinates to process |
| rsp | master | Stream(PixelResult)  | Return iteration count needed for the corresponding cmd transaction |

Let's specify the PixelTask bundle :

| Element Name | Type | Description |
| ------- | ---- |  --- |
| x | SFix | Coordinate in the mandelbrot space |
| y | SFix | Coordinate in the mandelbrot space |


Let's specify the PixelResult bundle :

| Element Name | Type | Description |
| ------- | ---- |  --- |
| iteration | UInt | Number of iteration required to solve the mandelbrot coordinates |

There is the reference picture that you should get when you run the test : 

![](assets/ref.png)

Important : The PixelSolver implementation should not be complicated. It can fit in 40 lines.


## Part 2 : PixelSolverMultiCore
The interface of the PixelSolverMultiCore is exactly the same than the PixelSolver. There is just an additional construction parameter named `coreCount` which specify how many PixelSolver you want to instantiate in parallel.

The to run input tasks in parallel, there is a very simple strategy :
- Take input tasks and dispatch them on PixelSolvers in the same order that they come. First task go to PixelSolver 0, second task go to PixelSolver 1 and so on.
- Arbitrate the outputs of all PixelSolver by the same way. First take the PixelSolver 0 output, then take the PixelSolver 1 output and so on.

There is a PixelSolverMultiCore diagram :

![](assets/PixelSolverMultiCore.svg)

So, you will have to implement the Dispatcher and the Arbiter and then the PixelSolverMultiCore in order to get maximum performance ;).